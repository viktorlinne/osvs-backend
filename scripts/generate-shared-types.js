#!/usr/bin/env node
/**
 * Generator stub: uses Prisma DMMF (if available) to generate Zod+TS files
 * Usage (rough):
 * 1. Install dev deps: `npm i -D @prisma/sdk` and ensure `prisma/schema.prisma` exists.
 * 2. Run: `node scripts/generate-shared-types.js --schema=./prisma/schema.prisma --out=../shared-types/src/generated.ts`
 *
 * This script is a minimal starting point — it will attempt to load @prisma/sdk and print instructions if not present.
 */
const fs = require("fs");
const path = require("path");

async function main() {
  const args = process.argv.slice(2);
  const opts = {};
  args.forEach((a) => {
    const [k, v] = a.split("=");
    if (k.startsWith("--")) opts[k.slice(2)] = v;
  });
  const schemaPath =
    opts.schema || path.resolve(process.cwd(), "prisma/schema.prisma");
  const outPath =
    opts.out || path.resolve(process.cwd(), "../shared-types/src/generated.ts");

  if (!fs.existsSync(schemaPath)) {
    console.error("Prisma schema not found at:", schemaPath);
    console.error(
      "Please run `npx prisma init` or place your schema at that location, or pass --schema=path"
    );
    process.exit(1);
  }

  let sdk;
  try {
    sdk = require("@prisma/sdk");
  } catch (e) {
    console.error(
      "@prisma/sdk not installed. Install with: npm i -D @prisma/sdk"
    );
    console.error(
      "This script can then generate a starting Zod file from your Prisma schema."
    );
    process.exit(1);
  }

  const schema = fs.readFileSync(schemaPath, "utf8");
  const dmmf = await sdk.getDMMF({ datamodel: schema });

  // Very small generator: create zod skeletons for each model
  const lines = [];
  lines.push(
    "// Generated by scripts/generate-shared-types.js — edit as needed"
  );
  lines.push("import { z } from 'zod';\n");

  for (const model of dmmf.datamodel.models) {
    const name = model.name;
    lines.push(`export const ${name}Schema = z.object({`);
    for (const field of model.fields) {
      // map basic scalar types
      let t = "z.unknown()";
      if (field.kind === "scalar") {
        switch (field.type) {
          case "String":
            t = "z.string()";
            break;
          case "Int":
            t = "z.number().int()";
            break;
          case "Float":
            t = "z.number()";
            break;
          case "Boolean":
            t = "z.boolean()";
            break;
          case "DateTime":
            t = "z.string()";
            break;
          default:
            t = "z.unknown()";
        }
        if (field.isList) t = `z.array(${t})`;
        if (!field.isRequired) t = `${t}.optional()`;
      } else if (field.kind === "object") {
        // relation — reference by name (user may adjust)
        t = `z.any()`;
        if (field.isList) t = `z.array(${t})`;
        if (!field.isRequired) t = `${t}.optional()`;
      }
      lines.push(`  ${field.name}: ${t},`);
    }
    lines.push(`});\nexport type ${name} = z.infer<typeof ${name}Schema>;\n`);
  }

  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, lines.join("\n"), "utf8");
  console.log("Wrote generated file to", outPath);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
